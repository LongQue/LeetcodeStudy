# 生命游戏
Leetcode第289题：生命游戏。难度为Medium，通过率66.0%  
链接：https://leetcode-cn.com/problems/game-of-life
# 题目描述
    给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live(1)即为活细胞或 dead(0)即为死细胞。  
    每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
    如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
    如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
    如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
    如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
    根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，  
    其中细胞的出生和死亡是同时发生的。
    示例:
    输入: 
    [
      [0,1,0],
      [0,0,1],
      [1,1,1],
      [0,0,0]
    ]
    输出: 
    [
      [0,0,0],
      [1,0,1],
      [0,1,1],
      [0,1,0]
    ]  
    进阶:使用原地算法
# 解题
个人流程：5分钟思路（×）->参考思路(√)->30分编码（√）->1ms,34.9M,87.29%
## 思路解析
1、逻辑题，无算法  
2、变化规律伪代码： 
```java
if(cur)
    if(aroundAliveNum(cur)<2||aroundAliveNum(cur)>3)
        cur=0;
else
    if(aroundAliveNum(cur)==3)
        cur=1;
```
3、由于需要同时变更，也就是说需要记录完整个数组所有元素的变化     
非原地算法直接new新数组即可，原地算法需要在元素本身动手脚,第一遍遍历给予状态变化标记，第二遍遍历由标记修改状态   
难点：如何在记录即将到来的变化的同时，不影响其当前live和dead状态判断  
### 替换
dead和live的转化存在四种状态  
dead->dead 00  
live->dead 01  
dead->live 10  
live->live 11  
用0 1 2 3记录变化的同时，0 2代表当前节点的dead状态，1 3代表当前节点的live状态  
题目样例：  
输入     | 计算周围live| 标记状态转化 |    输出  

[0,1,0]  |  [1,1,2]    |    [0,1,0]  |   [0,0,0]    
[0,0,1]  |  [3,5,3]    |    [2,0,3]  |   [1,0,1]    
[1,1,1]  |  [1,3,2]    |    [1,3,3]  |   [0,1,1]    
[0,0,0]  |  [2,3,2]    |    [0,2,0]  |   [0,1,0]    
至于为什么用00~11如此对应，第三个遍历一遍元素右移一格即可得出第四个
## 代码实现  
```java
int[] dx = new int[]{1, 1, 1, -1, -1, -1, 0, 0};
    int[] dy = new int[]{-1, 0, 1, -1, 1, 0, 1, -1};

    public void gameOfLife(int[][] board)
    {
       for (int i = 0; i < board.length; i++)
        {
            for (int j = 0; j < board[0].length; j++)
            {
                int num = 0;
                for (int h = 0; h < 8; h++)                    //for计算周围存活数
                {
                    int x = i + dx[h];
                    int y = j + dy[h];

                    if (y >= 0 && y < board[0].length && x >= 0 && x < board.length && (board[x][y] == 1 || board[x][y] == 3))
                    {
                        num++;
                    }
                }
                //一个三目运算符套着两个三目运算符，即算上替换之后的第二步伪代码
                board[i][j] = (board[i][j] == 1) ? ((num < 2 || num > 3) ? 1 : 3) : ((num == 3) ? 2 : 0);
            }
        }
        for (int i = 0; i < board.length; i++)
        {
            for (int j = 0; j < board[0].length; j++)
            {
                board[i][j] = board[i][j] >> 1;
            }
        }
    }
```
